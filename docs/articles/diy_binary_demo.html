<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DIY modeling of a binary network outcome • amen</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="DIY modeling of a binary network outcome">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">amen</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">1.4.3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/binary_demo.html">Modeling a binary network outcome</a>
    </li>
    <li>
      <a href="../articles/diy_Poisson_demo.html">DIY overdispersed Poisson network model</a>
    </li>
    <li>
      <a href="../articles/diy_binary_demo.html">DIY modeling of a binary network outcome</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="http://github.com/pdhoff/amen">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>DIY modeling of a binary network outcome</h1>
                        <h4 class="author">Peter Hoff</h4>
            
            <h4 class="date">2018-07-31</h4>
      
      <small class="dont-index">Source: <a href="http://github.com/pdhoff/amen/blob/master/vignettes/diy_binary_demo.Rmd"><code>vignettes/diy_binary_demo.Rmd</code></a></small>
      <div class="hidden name"><code>diy_binary_demo.Rmd</code></div>

    </div>

    
    
<p>The <code>amen</code> package provides wrapper functions <code>ame</code> and <code>ame_rep</code> for fitting a wide variety of AME models. However, wrapper functions can be opaque, and even wrapper functions with many options are limited by the energy and imagination of their authors. Therefore, some users may prefer to use some of the low-level <code>amen</code> functions to build their own custom Gibbs samplers for AME model fitting.</p>
<p>In this vignette, I show how to build such a sampler for a binary AME model. The example data we will use is the international relations data <code>IR90s</code> that comes with the <code>amen</code> package. We will model the binary indicator of conflict initiation between pairs of countries. Note that this dyadic variable is a count of the number of conflicts. For the purpose of this example, we dichotomize it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(amen)

Y&lt;-<span class="dv">1</span>*(IR90s$dyadvars[,,<span class="st">"conflicts"</span>] &gt;<span class="dv">0</span> )

<span class="kw"><a href="../reference/netplot.html">netplot</a></span>(Y,<span class="dt">plot.iso=</span><span class="ot">FALSE</span>,<span class="dt">plotnames=</span><span class="ot">TRUE</span>)</code></pre></div>
<p><img src="diy_binary_demo_files/figure-html/unnamed-chunk-1-1.png" width="700"></p>
<p>Which pairs of countries have conflicts? Well, poor countries that are far away from each other don’t have conflicts. With this in mind, let’s fit a model of international conflict that has as predictors the GDPs of the initiator and target countries, as well as the geographic distance between the pair (both on a log scale):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Xn&lt;-<span class="kw">log</span>(IR90s$nodevars[,<span class="dv">2</span>])
Xd&lt;-<span class="kw">log</span>(IR90s$dyadvars[,,<span class="dv">3</span>]+<span class="dv">1</span>) </code></pre></div>
<p>The binary probit AME model we will fit to <code>Y</code>, <code>Xn</code> and <code>Xd</code> is <span class="math display">\[
\begin{align*}
z_{i,j} &amp; = \beta_0 + \beta_r \text{gdp}_i + \beta_c \text{gdp}_j + \beta_d \text{dist}_{i,j}  + u_i^\top v_j + a_i +b_j + \epsilon_{i,j}  \\
y_{i,j} &amp; = 1( z_{i,j}&gt; 0 ) 
\end{align*} 
\]</span> where <span class="math inline">\(\text{Var}{ (\begin{smallmatrix} a_i \\ b_i \end{smallmatrix} ) } = \Sigma_{ab}\)</span>, <span class="math inline">\(\text{Var}{ (\begin{smallmatrix} u_i \\ v_i \end{smallmatrix} ) } = \Sigma_{uv}\)</span>, and <span class="math display">\[ \text{Var}{ ( \begin{smallmatrix} \epsilon_{i,j} \\ \epsilon_{j,i}\end{smallmatrix}) } = \Sigma_\epsilon =   \sigma^2  \begin{pmatrix}  1 &amp; \rho \\ \rho &amp; 1 \end{pmatrix}.
\]</span></p>
<p>We will construct a Gibbs sampler to approximate the joint posterior distribution of all unknown quantities, which includes</p>
<ul>
<li><p>the global parameters <span class="math inline">\(\beta, \Sigma_{ab}, \Sigma_{uv}, \rho\)</span>;</p></li>
<li><p>the latent nodal effects <span class="math inline">\(\{ (a_i, b_i, u_i, v_i): i=1,\ldots, n\}\)</span>;</p></li>
<li><p>the unobserved latent dyadic variables <span class="math inline">\(z_{i,j}\)</span>.</p></li>
</ul>
<p>Here we go. First note that the “linear regression” part of the model may be written as <span class="math inline">\(\beta^\top x_{i,j}\)</span> where <span class="math inline">\(x_{i,j} = ( 1, \text{gdp}_i , \text{gdp}_j , \text{dist}_{i,j} )\)</span>. and <span class="math inline">\(\beta = ( \beta_0 , \beta_r, \beta_c \beta_d)\)</span>. We construct the “design array”, the <span class="math inline">\(n\times n \times p = 130 \times 130 \times 4\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">X&lt;-<span class="kw"><a href="../reference/design_array.html">design_array</a></span>(<span class="dt">Xrow=</span>Xn,<span class="dt">Xcol=</span>Xn,<span class="dt">Xdyad=</span>Xd,<span class="dt">n=</span><span class="kw">nrow</span>(Y)) </code></pre></div>
<p>If you are not sure what this is doing, examine <code>X</code> yourself or study the following output:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(X) </code></pre></div>
<pre><code>## [1] 130 130   4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dimnames</span>(X)[[<span class="dv">3</span>]] </code></pre></div>
<pre><code>## [1] "intercept" ".row"      ".col"      ".dyad"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">X[<span class="dv">1</span>:<span class="dv">3</span>,<span class="dv">1</span>:<span class="dv">3</span>,<span class="dv">1</span>]</code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    1    1
## [2,]    1    1    1
## [3,]    1    1    1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">X[<span class="dv">1</span>:<span class="dv">3</span>,<span class="dv">1</span>:<span class="dv">3</span>,<span class="dv">2</span>]</code></pre></div>
<pre><code>##          [,1]     [,2]     [,3]
## [1,] 2.959587 2.959587 2.959587
## [2,] 2.191654 2.191654 2.191654
## [3,] 4.894925 4.894925 4.894925</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">X[<span class="dv">1</span>:<span class="dv">3</span>,<span class="dv">1</span>:<span class="dv">3</span>,<span class="dv">3</span>]</code></pre></div>
<pre><code>##          [,1]     [,2]     [,3]
## [1,] 2.959587 2.191654 4.894925
## [2,] 2.959587 2.191654 4.894925
## [3,] 2.959587 2.191654 4.894925</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">X[<span class="dv">1</span>:<span class="dv">3</span>,<span class="dv">1</span>:<span class="dv">3</span>,<span class="dv">4</span>]</code></pre></div>
<pre><code>##          [,1]      [,2]      [,3]
## [1,] 0.000000 1.6733512 1.9257074
## [2,] 1.673351 0.0000000 0.9321641
## [3,] 1.925707 0.9321641 0.0000000</code></pre>
<p>Next we need starting values for all (but one) of our unknown quantities. Because this is just a tutorial I will set these lazily:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Sab&lt;-<span class="kw">diag</span>(<span class="dv">2</span>) 

rho&lt;-<span class="dv">0</span> 

R&lt;-<span class="dv">2</span> 

Suv&lt;-<span class="kw">diag</span>(<span class="dv">2</span>*R)

U&lt;-V&lt;-<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="kw">nrow</span>(Y),R) 

<span class="co"># just need Z[i,j]&lt;0 if Y[i,j]=0, Z[i,j]&gt;0 if Y[i,j]=1  </span>
Z&lt;-<span class="kw">matrix</span>(<span class="kw"><a href="../reference/zscores.html">zscores</a></span>(Y,<span class="dt">ties.method=</span><span class="st">"random"</span>),<span class="kw">nrow</span>(Y),<span class="kw">nrow</span>(Y))
Z&lt;-Z-<span class="kw">max</span>(Z[!<span class="kw">is.na</span>(Y) &amp;<span class="st"> </span>Y==<span class="dv">0</span> ] ) 
<span class="kw">diag</span>(Z)&lt;-<span class="dv">0</span></code></pre></div>
<p>Finally, we specify some aspects of the prior distribution. The functions in the <code>amen</code> package use a <span class="math inline">\(g\)</span>-prior for <span class="math inline">\(\beta\)</span> by default (but this can be changed) and an arc-sine prior or uniform prior for <span class="math inline">\(\rho\)</span>. The priors for <span class="math inline">\(\Sigma_{ab}\)</span> and <span class="math inline">\(\Sigma_{uv}\)</span> are</p>
<ul>
<li>
<span class="math inline">\(\Sigma_{ab}^{-1} \sim W( \Sigma_{ab0}^{-1}, \eta_0 )\)</span>;</li>
<li>
<span class="math inline">\(\Sigma_{uv}^{-1} \sim W( \Sigma_{uv0}^{-1} , \kappa_0)\)</span>.</li>
</ul>
<p>Sparse network datasets may not provide much information with which to estimate <span class="math inline">\(\Sigma_{ab}\)</span> and <span class="math inline">\(\Sigma_{uv}\)</span>. For such data, estimation stability can be improved by concentrating the scale of these covariance matrices near some empirical Bayes estimate, where the concentration is decreasing with the amount of information in the data. The following calculations provide one way to adaptively choose the priors for <span class="math inline">\(\Sigma_{ab}\)</span> and <span class="math inline">\(\Sigma_{uv}\)</span> based on the information in the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ybar&lt;-<span class="kw">mean</span>(Y,<span class="dt">na.rm=</span><span class="ot">TRUE</span>) ; mu&lt;-<span class="kw">qnorm</span>(ybar)
E&lt;-<span class="st"> </span>(Y -<span class="st"> </span>ybar)/<span class="kw">dnorm</span>(<span class="kw">qnorm</span>(ybar)) ; <span class="kw">diag</span>(E)&lt;-<span class="dv">0</span>
a&lt;-<span class="kw">rowMeans</span>(E,<span class="dt">na.rm=</span><span class="ot">TRUE</span>)  ; a[<span class="kw">is.na</span>(a)]&lt;-<span class="dv">0</span>
b&lt;-<span class="kw">colMeans</span>(E,<span class="dt">na.rm=</span><span class="ot">TRUE</span>)  ; b[<span class="kw">is.na</span>(b)]&lt;-<span class="dv">0</span>

vscale&lt;-<span class="kw">mean</span>(<span class="kw">diag</span>(<span class="kw">cov</span>(<span class="kw">cbind</span>(a,b))))
PHAT&lt;-<span class="kw">pnorm</span>(mu+<span class="kw">outer</span>(a,b,<span class="st">"+"</span>))
vdfmlt&lt;-.<span class="dv">25</span>/<span class="kw">mean</span>(PHAT*(<span class="dv">1</span>-PHAT))

Sab0&lt;-<span class="kw">diag</span>(<span class="dv">2</span>)*vscale 
eta0&lt;-<span class="kw">round</span>(<span class="dv">4</span>*vdfmlt)       

Suv0&lt;-<span class="kw">diag</span>(<span class="dv">2</span>*R)*vscale 
kappa0&lt;-<span class="kw">round</span>((<span class="dv">2</span>*R<span class="dv">+2</span>)*vdfmlt)  </code></pre></div>
<p>Now all we need is a for-loop that iteratively updates the unknown quantities from their full conditional distributions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BETA&lt;-<span class="ot">NULL</span> ; RHO&lt;-<span class="ot">NULL</span> ; UV&lt;-<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="kw">nrow</span>(Y),<span class="kw">nrow</span>(Y))

for(s in <span class="dv">1</span>:<span class="dv">10000</span>)
{ 
  <span class="co"># update beta, a and b  </span>
  tmp&lt;-<span class="kw"><a href="../reference/rbeta_ab_fc.html">rbeta_ab_fc</a></span>(Z,Sab,rho,X,<span class="dt">offset=</span>U%*%<span class="kw">t</span>(V))
  beta&lt;-tmp$beta ; a&lt;-tmp$a ; b&lt;-tmp$b

  <span class="co"># update UV </span>
  tmp&lt;-<span class="kw"><a href="../reference/rUV_fc.html">rUV_fc</a></span>(Z,U,V,Suv,rho,<span class="dt">offset=</span><span class="kw"><a href="../reference/Xbeta.html">Xbeta</a></span>(X,beta) +<span class="st"> </span><span class="kw">outer</span>(a,b,<span class="st">"+"</span>)) 
  U&lt;-tmp$U ; V&lt;-tmp$V

  <span class="co"># update Suv</span>
  Suv&lt;-<span class="kw"><a href="../reference/rSuv_fc.html">rSuv_fc</a></span>(U,V,<span class="dt">Suv0=</span>Suv0,<span class="dt">kappa0=</span>kappa0) 

  <span class="co"># update Sab</span>
  Sab&lt;-<span class="kw"><a href="../reference/rSab_fc.html">rSab_fc</a></span>(a,b,<span class="dt">Sab0=</span>Sab0,<span class="dt">eta0=</span>eta0)

  <span class="co"># update rho </span>
  rho&lt;-<span class="kw"><a href="../reference/rrho_mh.html">rrho_mh</a></span>(Z,rho,<span class="dt">offset=</span><span class="kw"><a href="../reference/Xbeta.html">Xbeta</a></span>(X,beta)+<span class="kw">outer</span>(a,b,<span class="st">"+"</span>)+U%*%<span class="kw">t</span>(V)) 

  <span class="co"># update Z </span>
  Z&lt;-<span class="kw"><a href="../reference/rZ_bin_fc.html">rZ_bin_fc</a></span>(Z, <span class="kw"><a href="../reference/Xbeta.html">Xbeta</a></span>(X,beta)+<span class="kw">outer</span>(a,b,<span class="st">"+"</span>)+U%*%<span class="kw">t</span>(V), rho, Y)  

  <span class="co"># periodically save some output   </span>
  if(s%%<span class="dv">25</span>==<span class="dv">0</span> &amp;<span class="st"> </span>s&gt;<span class="dv">500</span>) 
  { 
    <span class="kw">cat</span>(<span class="kw">round</span>(<span class="dv">100</span>*s/<span class="dv">10000</span>),<span class="st">"% complete</span><span class="ch">\n</span><span class="st">"</span>) 
    BETA&lt;-<span class="kw">rbind</span>(BETA,beta) 
    RHO&lt;-<span class="kw">c</span>(RHO,rho) 
    UV&lt;-UV+U%*%<span class="kw">t</span>(V)  
    <span class="kw">matplot</span>(BETA,<span class="dt">type=</span><span class="st">"l"</span>) 
  }
}</code></pre></div>
<p><img src="diy_binary_demo_files/figure-html/unnamed-chunk-7-1.png" width="700"></p>
<p>The mixing is a bit slow, so you would probably want to run the Markov chain longer to obtain some final results.</p>
<p>Here is the “wrapper” version, fitting the same model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fit&lt;-<span class="kw"><a href="../reference/ame.html">ame</a></span>(Y,<span class="dt">Xrow=</span>Xn,<span class="dt">Xcol=</span>Xn,<span class="dt">Xdyad=</span>Xd,<span class="dt">R=</span><span class="dv">2</span>,<span class="dt">family=</span><span class="st">"bin"</span>)</code></pre></div>
<p><img src="diy_binary_demo_files/figure-html/unnamed-chunk-8-1.png" width="700"></p>
<p>Now compare posterior density approximations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">for(j in <span class="dv">1</span>:<span class="dv">4</span>)
{
  <span class="kw">plot</span>(<span class="kw">density</span>(BETA[,j] ),<span class="dt">main=</span><span class="st">""</span>,<span class="dt">xlab=</span><span class="st">""</span>)
  <span class="kw">lines</span>(<span class="kw">density</span>(fit$BETA[,j] ),<span class="dt">col=</span><span class="st">"green"</span>) 
}</code></pre></div>
<p><img src="diy_binary_demo_files/figure-html/unnamed-chunk-9-1.png" width="700"></p>
<p>The longer you run the Markov chains, the closer the two approximations should get to each other (and to the actual posterior distribution).</p>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Peter Hoff, Bailey Fosdick, Alex Volfovsky.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
