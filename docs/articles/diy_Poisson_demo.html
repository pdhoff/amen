<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DIY overdispersed Poisson network model • amen</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="DIY overdispersed Poisson network model">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">amen</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">1.4.3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/binary_demo.html">Modeling a binary network outcome</a>
    </li>
    <li>
      <a href="../articles/diy_Poisson_demo.html">DIY overdispersed Poisson network model</a>
    </li>
    <li>
      <a href="../articles/diy_binary_demo.html">DIY modeling of a binary network outcome</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="http://github.com/pdhoff/amen">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>DIY overdispersed Poisson network model</h1>
                        <h4 class="author">Peter Hoff</h4>
            
            <h4 class="date">2018-07-31</h4>
      
      <small class="dont-index">Source: <a href="http://github.com/pdhoff/amen/blob/master/vignettes/diy_Poisson_demo.Rmd"><code>vignettes/diy_Poisson_demo.Rmd</code></a></small>
      <div class="hidden name"><code>diy_Poisson_demo.Rmd</code></div>

    </div>

    
    
<p>Many network outcomes are counts, such as the number of emails between individuals or the number of conflicts between countries. One way to model such outcomes is to treat them as ordinal and fit an ordinal probit model. This can be done with the <code>ame</code> command using the <code>family=ord</code> option. However, the MCMC algorithm for this model can take a long time to run, and can mix poorly if the data do not contain much information. In such cases, it may be preferable to use a more parametric approach, such as a Poisson regression model.</p>
<p>In this tutorial, I illustrate how to fit an overdispersed Poisson model to some network data with a count outcome, using the functions provided by the <code>amen</code> package. The model we will fit is the following:</p>
<p><span class="math display">\[
\begin{align*}
z_{i,j} &amp; = \beta^\top x_{i,j}   +  a_i +b_j + u_i^\top v_j + \epsilon_{i,j}  \\
y_{i,j}|z_{i,j}  &amp; \sim  \text{Poisson}( e^{z_{i,j}} ) 
\end{align*} 
\]</span> where <span class="math inline">\(\text{Var}{ (\begin{smallmatrix} a_i \\ b_i \end{smallmatrix} ) } = \Sigma_{ab}\)</span>, <span class="math inline">\(\text{Var}{ (\begin{smallmatrix} u_i \\ v_i \end{smallmatrix} ) } = \Sigma_{uv}\)</span>, and <span class="math display">\[ \text{Var}{ ( \begin{smallmatrix} \epsilon_{i,j} \\ \epsilon_{j,i}\end{smallmatrix}) } = \Sigma_\epsilon =   \sigma^2  \begin{pmatrix}  1 &amp; \rho \\ \rho &amp; 1 \end{pmatrix}. 
\]</span> We can think of the parameter <span class="math inline">\(\sigma^2\)</span> here as an overdispersion parameter, in the sense that if <span class="math inline">\(\sigma^2\)</span> were zero, then <span class="math inline">\(y_{i,j}\)</span> would be Poisson with mean <span class="math inline">\(\exp( \beta^\top x_{i,j} + a_i +b_j + u_i^\top v_j)\)</span>. On the other hand, if <span class="math inline">\(\sigma^2\)</span> is large then the variance of <span class="math inline">\(y_{i,j}\)</span> will be larger than <span class="math inline">\(\exp(\beta^\top x_{i,j} + a_i +b_j + u_i^\top v_j)\)</span>.</p>
<p>We will construct a Gibbs sampler to approximate the joint posterior distribution of all unknown quantities, which includes</p>
<ul>
<li><p>the global parameters <span class="math inline">\(\beta, \Sigma_{ab}, \Sigma_{uv}, \sigma^2, \rho\)</span>;</p></li>
<li><p>the latent nodal effects <span class="math inline">\(\{ (a_i, b_i, u_i, v_i): i=1,\ldots, n\}\)</span>;</p></li>
<li><p>the unobserved latent dyadic variables <span class="math inline">\(z_{i,j}\)</span>.</p></li>
</ul>
<p>We will fit a rank-1 AMEN model to the dataset on sheep dominance encounters that is included with the <code>amen</code> package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(amen)

Y&lt;-sheep$dom 
age&lt;-sheep$age 

Y[<span class="dv">1</span>:<span class="dv">8</span>,<span class="dv">1</span>:<span class="dv">8</span>] </code></pre></div>
<pre><code>##      V1 V2 V3 V4 V5 V6 V7 V8
## [1,] NA  0  0  0  0  0  0  1
## [2,]  0 NA  0  0  5  2  1  0
## [3,]  0  0 NA  0  7  4  0  0
## [4,]  0  0  8 NA  0  0  0  0
## [5,]  0  0  0  0 NA  1  0  0
## [6,]  0  0  0  7  0 NA  0  0
## [7,]  0  0  1  0  0  0 NA  0
## [8,]  0  1  1  4  5  3  0 NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">age[<span class="dv">1</span>:<span class="dv">8</span>]</code></pre></div>
<pre><code>## [1] 9 8 9 9 7 8 9 9</code></pre>
<p>Here, <span class="math inline">\(y_{i,j}\)</span> is the number of times sheep <span class="math inline">\(i\)</span> “dominated” sheep <span class="math inline">\(j\)</span> over some time period, and <span class="math inline">\(x_i\)</span> is the age of sheep <span class="math inline">\(i\)</span> in years.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">boxplot</span>( <span class="kw">apply</span>(Y,<span class="dv">1</span>,mean,<span class="dt">na.rm=</span><span class="ot">TRUE</span>) ~<span class="st"> </span>age )  
<span class="kw">boxplot</span>( <span class="kw">apply</span>(Y,<span class="dv">2</span>,mean,<span class="dt">na.rm=</span><span class="ot">TRUE</span>) ~<span class="st"> </span>age )  </code></pre></div>
<p><img src="diy_Poisson_demo_files/figure-html/unnamed-chunk-2-1.png" width="700"> Roughly speaking, older sheep dominate younger sheep.</p>
<p>Let’s fit a model for <span class="math inline">\(y_{i,j}\)</span> with main and interaction effects of age. Let <span class="math inline">\(x_{i} = \text{age}_i - \bar{\text{age}}\)</span> be the centered age variable, and let <span class="math inline">\(x_{i,j} = ( x_i , x_j, x_i x_j)\)</span>.<br>
The corresponding design matrix can be constructed as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x&lt;-sheep$age -<span class="st"> </span><span class="kw">mean</span>(sheep$age)

X&lt;-<span class="kw"><a href="../reference/design_array.html">design_array</a></span>(<span class="dt">Xrow=</span>x,<span class="dt">Xcol=</span>x,<span class="dt">Xdyad=</span><span class="kw">outer</span>(x,x)) </code></pre></div>
<p>Now we need some starting values for some of the unknown quantities in the model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z&lt;-<span class="kw">log</span>(Y<span class="dv">+1</span>) ; <span class="kw">diag</span>(Z)&lt;-<span class="dv">0</span> 

Sab&lt;-<span class="kw">diag</span>(<span class="dv">2</span>) 

R&lt;-<span class="dv">1</span> ; Suv&lt;-<span class="kw">diag</span>(<span class="dv">2</span>*R) ; U&lt;-V&lt;-<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="kw">nrow</span>(Y),R) 

s2&lt;-<span class="dv">1</span> ; rho&lt;-<span class="dv">0</span></code></pre></div>
<p>Now if we observed <span class="math inline">\(Z\)</span> and assumed it followed the AME model above, we could just use the following MCMC algorithm to approximate the joint posterior distribution of the AME model parameters:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">for(s in <span class="dv">1</span>:<span class="dv">10</span>)
{ 
  <span class="co"># update beta, a and b</span>
  tmp&lt;-<span class="kw"><a href="../reference/rbeta_ab_fc.html">rbeta_ab_fc</a></span>(Z,Sab,rho,X,s2,<span class="dt">offset=</span>U%*%<span class="kw">t</span>(V))
  beta&lt;-tmp$beta ; a&lt;-tmp$a ; b&lt;-tmp$b

  <span class="co"># update UV</span>
  tmp&lt;-<span class="kw"><a href="../reference/rUV_fc.html">rUV_fc</a></span>(Z,U,V,Suv,rho,<span class="dt">offset=</span><span class="kw"><a href="../reference/Xbeta.html">Xbeta</a></span>(X,beta)+<span class="kw">outer</span>(a,b,<span class="st">"+"</span>))
  U&lt;-tmp$U ; V&lt;-tmp$V

  <span class="co"># update Sab</span>
  Sab&lt;-<span class="kw"><a href="../reference/rSab_fc.html">rSab_fc</a></span>(a,b)

  <span class="co"># update Suv</span>
  Suv&lt;-<span class="kw"><a href="../reference/rSuv_fc.html">rSuv_fc</a></span>(U,V)

  <span class="co"># update s2</span>
  s2&lt;-<span class="kw"><a href="../reference/rs2_fc.html">rs2_fc</a></span>(Z,rho,<span class="dt">offset=</span><span class="kw"><a href="../reference/Xbeta.html">Xbeta</a></span>(X,beta)+<span class="kw">outer</span>(a,b,<span class="st">"+"</span>)+U%*%<span class="kw">t</span>(V))

  <span class="co"># update rho</span>
  rho&lt;-<span class="kw"><a href="../reference/rrho_mh.html">rrho_mh</a></span>(Z,rho,s2,<span class="dt">offset=</span><span class="kw"><a href="../reference/Xbeta.html">Xbeta</a></span>(X,beta)+<span class="kw">outer</span>(a,b,<span class="st">"+"</span>)+U%*%<span class="kw">t</span>(V))
}</code></pre></div>
<p>However, in our model <span class="math inline">\(Z\)</span> is the matrix of unknown log expectations of the elements of <span class="math inline">\(Y\)</span>. To account for the fact that <span class="math inline">\(Z\)</span> is unknown, we need to integrate/simulate over the possible values of <span class="math inline">\(Z\)</span> in the Markov chain. This can be done by adding a Metropolis update for <span class="math inline">\(Z\)</span> to the above MCMC algorithm. We do this as follows:</p>
<ol style="list-style-type: decimal">
<li><p>Simulate a candidate value for each <span class="math inline">\(z_{i,j}\)</span>: <span class="math inline">\(z^*_{i,j} \sim N(z_{i,j}, c \sigma^2 )\)</span>, where <span class="math inline">\(c\)</span> is a tuning parameter.</p></li>
<li><p>Replace the <em>pair</em> <span class="math inline">\((z_{i,j},z_{j,i})\)</span> with the proposed values <span class="math inline">\((z_{i,j}^*,z_{j,i}^*)\)</span> if <span class="math display">\[
   \log \frac{ p(y_{i,j} | z_{i,j}^* ) p(y_{j,i} | z_{j,i}^* ) p(z_{i,j}^*,z_{j,i}^*) }
 { p(y_{i,j} | z_{i,j} ) p(y_{j,i} | z_{j,i} ) p(z_{i,j},z_{j,i}) }  &gt; \log h 
\]</span> where <span class="math inline">\(h \sim U(0,1)\)</span>. Here <span class="math inline">\(p(z_{i,j}, z_{j,i} )\)</span> is the joint density of <span class="math inline">\((z_{i,j},z_{j,i})\)</span> conditional on <span class="math inline">\(\beta, a_i, b_i, u_i, v_i, a_j,b_j, u_j, v_j\)</span> and <span class="math inline">\(\rho\)</span> and <span class="math inline">\(\sigma^2\)</span>. This joint density is not exotic: it is simply a bivariate normal density for <span class="math inline">\((z_{i,j}, z_{j,i} )\)</span> where the mean vector is <span class="math inline">\(( \beta^\top x_{i,j} +a_i+b_j +u_i^\top v_j , \beta^\top x_{j,i} +a_j+b_i +u_j^\top v_i )\)</span> and covariance matrix <span class="math inline">\(\Sigma_\epsilon\)</span>.</p></li>
</ol>
<p>Calculation of the log numerator (and denominator) in the above ratio can be done with the <code>amen</code> function <code>ldZgbme</code>. The letters stand for “log density of Z from a gbme model”. You can search the web for more on gbme models. In R, updating <span class="math inline">\(Z\)</span> using this procedure looks like the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># propose candidate Z</span>
Zp&lt;-Z+<span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="kw">nrow</span>(Y)^<span class="dv">2</span>),<span class="kw">nrow</span>(Y),<span class="kw">nrow</span>(Y))*<span class="kw">sqrt</span>(s2)

<span class="co"># compute acceptance ratio</span>
EZ&lt;-<span class="kw"><a href="../reference/Xbeta.html">Xbeta</a></span>(X,beta)+<span class="kw">outer</span>(a,b,<span class="st">"+"</span>)+U%*%<span class="kw">t</span>(V)
lr&lt;-<span class="kw"><a href="../reference/ldZgbme.html">ldZgbme</a></span>(Zp,Y,function(y,z){ <span class="kw">dpois</span>(y,<span class="kw">exp</span>(z),<span class="dt">log=</span><span class="ot">TRUE</span>) },EZ,rho,s2) -
<span class="st">    </span><span class="kw"><a href="../reference/ldZgbme.html">ldZgbme</a></span>(Z, Y,function(y,z){ <span class="kw">dpois</span>(y,<span class="kw">exp</span>(z),<span class="dt">log=</span><span class="ot">TRUE</span>) },EZ,rho,s2)

<span class="co"># simulate symmetric matrix of (log) uniform rvs</span>
lh&lt;-<span class="kw">matrix</span>(<span class="kw">log</span>(<span class="kw">runif</span>(<span class="kw">nrow</span>(Y)^<span class="dv">2</span>)),<span class="kw">nrow</span>(Y),<span class="kw">nrow</span>(Y))
lh[<span class="kw">lower.tri</span>(lh)]&lt;-<span class="kw">t</span>(lh)[<span class="kw">lower.tri</span>(lh)]

<span class="co"># update dyads for which lr&gt;lh, and keep track of acceptances</span>
Z[lr&gt;lh]&lt;-Zp[lr&gt;lh]</code></pre></div>
<p>Note that the <code>ldZgbme</code> function takes as an argument a function that specifies the log density (or mass) function for each <span class="math inline">\(y_{i,j}\)</span> given <span class="math inline">\(z_{i,j}\)</span>. So for our Poisson model, this function is <code>function(y,z){ dpois(y,exp(z),log=TRUE) }</code>. You can fit other types of models by specifying different log density functions.</p>
<p>Let’s implement this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">#### Starting values
Z&lt;-<span class="kw">log</span>(Y<span class="dv">+1</span>) ; <span class="kw">diag</span>(Z)&lt;-<span class="dv">0</span>

Sab&lt;-<span class="kw">diag</span>(<span class="dv">2</span>)

R&lt;-<span class="dv">1</span> ; Suv&lt;-<span class="kw">diag</span>(<span class="dv">2</span>*R) ; U&lt;-V&lt;-<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="kw">nrow</span>(Y),R) 

s2&lt;-<span class="dv">1</span> ; rho&lt;-<span class="dv">0</span>

#### Parameter values to be saved
BETA&lt;-VE&lt;-LL&lt;-<span class="ot">NULL</span>
ACC&lt;-<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="kw">nrow</span>(Y),<span class="kw">nrow</span>(Y))

#### MCMC 
<span class="kw">set.seed</span>(<span class="dv">1</span>)
for(s in <span class="dv">1</span>:<span class="dv">10000</span>)
{ 
  ## Update AMEN parameters

  <span class="co"># update beta, a and b</span>
  tmp&lt;-<span class="kw"><a href="../reference/rbeta_ab_fc.html">rbeta_ab_fc</a></span>(Z,Sab,rho,X,s2,<span class="dt">offset=</span>U%*%<span class="kw">t</span>(V))
  beta&lt;-tmp$beta ; a&lt;-tmp$a ; b&lt;-tmp$b

  <span class="co"># update UV</span>
  tmp&lt;-<span class="kw"><a href="../reference/rUV_fc.html">rUV_fc</a></span>(Z,U,V,Suv,rho,<span class="dt">offset=</span><span class="kw"><a href="../reference/Xbeta.html">Xbeta</a></span>(X,beta)+<span class="kw">outer</span>(a,b,<span class="st">"+"</span>))
  U&lt;-tmp$U ; V&lt;-tmp$V

  <span class="co"># update Sab</span>
  Sab&lt;-<span class="kw"><a href="../reference/rSab_fc.html">rSab_fc</a></span>(a,b)

  <span class="co"># update Suv</span>
  Suv&lt;-<span class="kw"><a href="../reference/rSuv_fc.html">rSuv_fc</a></span>(U,V)

  <span class="co"># update s2</span>
  s2&lt;-<span class="kw"><a href="../reference/rs2_fc.html">rs2_fc</a></span>(Z,rho,<span class="dt">offset=</span><span class="kw"><a href="../reference/Xbeta.html">Xbeta</a></span>(X,beta)+<span class="kw">outer</span>(a,b,<span class="st">"+"</span>)+U%*%<span class="kw">t</span>(V))

  <span class="co"># update rho</span>
  rho&lt;-<span class="kw"><a href="../reference/rrho_mh.html">rrho_mh</a></span>(Z,rho,s2,<span class="dt">offset=</span><span class="kw"><a href="../reference/Xbeta.html">Xbeta</a></span>(X,beta)+<span class="kw">outer</span>(a,b,<span class="st">"+"</span>)+U%*%<span class="kw">t</span>(V))



  ## Update Z 
 
  <span class="co"># propose candidate Z </span>
  Zp&lt;-Z+<span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="kw">nrow</span>(Y)^<span class="dv">2</span>),<span class="kw">nrow</span>(Y),<span class="kw">nrow</span>(Y))*<span class="kw">sqrt</span>(s2)   

  <span class="co"># compute acceptance ratio </span>
  EZ&lt;-<span class="kw"><a href="../reference/Xbeta.html">Xbeta</a></span>(X,beta)+<span class="kw">outer</span>(a,b,<span class="st">"+"</span>)+U%*%<span class="kw">t</span>(V)
  lr&lt;-<span class="kw"><a href="../reference/ldZgbme.html">ldZgbme</a></span>(Zp,Y,function(y,z){ <span class="kw">dpois</span>(y,<span class="kw">exp</span>(z),<span class="dt">log=</span><span class="ot">TRUE</span>) },EZ,rho,s2) -
<span class="st">      </span><span class="kw"><a href="../reference/ldZgbme.html">ldZgbme</a></span>(Z, Y,function(y,z){ <span class="kw">dpois</span>(y,<span class="kw">exp</span>(z),<span class="dt">log=</span><span class="ot">TRUE</span>) },EZ,rho,s2) 

  <span class="co"># simulate symmetric matrix of (log) uniform rvs</span>
  lh&lt;-<span class="kw">matrix</span>(<span class="kw">log</span>(<span class="kw">runif</span>(<span class="kw">nrow</span>(Y)^<span class="dv">2</span>)),<span class="kw">nrow</span>(Y),<span class="kw">nrow</span>(Y))
  lh[<span class="kw">lower.tri</span>(lh)]&lt;-<span class="kw">t</span>(lh)[<span class="kw">lower.tri</span>(lh)]  

  <span class="co"># update dyads for which lr&gt;lh, and keep track of acceptances</span>
  Z[lr&gt;lh]&lt;-Zp[lr&gt;lh] 
  ACC[lr&gt;lh]&lt;-ACC[lr&gt;lh]+<span class="dv">1</span>  



  ## Output
  if(s%%<span class="dv">25</span>==<span class="dv">0</span>) 
  {  
    <span class="kw">cat</span>(s,<span class="kw">range</span>(ACC/s),<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>) 
    BETA&lt;-<span class="kw">rbind</span>(BETA,beta) 
    VE&lt;-<span class="kw">rbind</span>(VE,<span class="kw">c</span>(s2,rho))    

    <span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>),<span class="dt">mar=</span><span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>),<span class="dt">mgp=</span><span class="kw">c</span>(<span class="fl">1.75</span>,.<span class="dv">75</span>,<span class="dv">0</span>)) 
    <span class="kw">matplot</span>(BETA,<span class="dt">type=</span><span class="st">"l"</span>) 
    LL&lt;-<span class="kw">c</span>(LL,<span class="kw">sum</span>(<span class="kw">dpois</span>(Y,<span class="kw">exp</span>(Z),<span class="dt">log=</span><span class="ot">TRUE</span>),<span class="dt">na.rm=</span><span class="ot">TRUE</span>)) ; <span class="kw">plot</span>(LL,<span class="dt">type=</span><span class="st">"l"</span>)
    <span class="kw">hist</span>(ACC/s) 
  }
}</code></pre></div>
<p><img src="diy_Poisson_demo_files/figure-html/unnamed-chunk-7-1.png" width="700"></p>
<p>Let’s interpret the parameter estimates:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(BETA,<span class="dv">2</span>,mean)</code></pre></div>
<pre><code>## [1] -1.62872581  0.19926245 -0.33723549  0.05615933</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(BETA,<span class="dv">2</span>,sd)</code></pre></div>
<pre><code>## [1] 0.31035583 0.08344497 0.05881178 0.01047963</code></pre>
<p>So the older a sheep is, the more likely it is do dominate others, and the younger a sheep is, the more likely it is to be dominated. Also, the interaction term suggests some homophily on age in terms of number of dominance encounters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(VE,<span class="dv">2</span>,mean) </code></pre></div>
<pre><code>## [1]  0.9692351 -0.7259700</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apply</span>(VE,<span class="dv">2</span>,sd) </code></pre></div>
<pre><code>## [1] 0.1199476 0.1731239</code></pre>
<p>There is a strong negative dyadic correlation for these data, reflecting that if <span class="math inline">\(i\)</span> dominates <span class="math inline">\(j\)</span> frequently, <span class="math inline">\(j\)</span> dominates <span class="math inline">\(i\)</span> less frequently than expected based on the age effects and random effects.</p>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Peter Hoff, Bailey Fosdick, Alex Volfovsky.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
